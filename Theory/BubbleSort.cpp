/*
Bubble Sort

인접한 두 원소를 비교하여 정렬하는 간당한 정렬 알고리즘
큰 수가 뒤로 오는 방식으로 동작한다고 하여 버블 정렬이라고 함

** 버블 정렬의 동작 원리

1. 두 원소 비교
	- 배열의 맨 앞에서부터 인접한 두 원소를 비교
2. Swap
	- 만약 앞의 원소가 뒤의 원소보다 크다면, 두 원소를 교환(Swap)
3. 이 과정을 끝까지 반복
	- 배열의 끝까지 가면 가장 큰 원소가 맨 뒤로 오게 됨
4. 반복
	- 끝까지 정렬이 되지 않으면, 다시 앞에서부터 비교하여 정렬을 반복

이 과정에서 가장 큰 수가 맨 뒤로 가는 것처럼, 점점 더 큰 수가 뒤로 밀려나는 형태로 정렬이 진행 됨

** 버블 정렬의 특징

- 시간 복잡도	: 최악의 경우에는 O(n^2) (배열의 크기가 클 때 비효율적)
- 공간 복잡도	: O(1) (기존 배열을 수정하며 정렬하므로 추가 공간이 필요치 않음)
- 안정성			: 원소가 같을 경우, 그 순서가 변경되지 않으므로 안정적인 정렬 알고리즘

** 버블 정렬의 동작 예시

[5, 3, 8, 4, 2]
1. 5와 3 비교 -> 5 > 3, 그래서 5, 3 swap -> 3, 5, 8, 4, 2
2. 5와 8 비교 -> 5 < 8, 아무 일도 일어나지 않음
3. 8과 4 비교 -> 8 > 4, 그래서 8, 4 swap -> 3, 5, 4, 8, 2
4. 8과 2 비교 -> 8 > 2, 그래서 8, 2 swap -> 3, 6, 4, 2, 8

위의 과정을 계속 반복하면서 마지막엔 가자아 큰 값이 배열의 끝에 오게 됨

** 버블 정렬의 장단점

* 장점
	- 구현이 매우 간단하고 직관적
	- 작은 배열에서는 충분히 빠르고 유용하게 사용 가능

* 단점
	- 시간 복잡도가 O(n^2)로 매우 비효율적, 특히 배열 크기가 커지면 성능이 급격하게 저하
	- 다른 정렬 알고리즘( ex) 퀵, 병합 )에 비해 성능이 떨어짐

*/

#include "BubbleSort.h"

namespace BUBBLE_SORT
{
	void BubbleSort(vector<int>& arr, int n)
	{
		bool swapped;	// 교환 여부 체크 변수
		
		// 배열의 크기 n - 1만큼 반복
		for (int i = 0; i < n - 1; ++i)
		{
			swapped = false;	// 이번 패스에서 교환이 없으면 종료

			// 한 번의 패스에서 가장 큰 값을 뒤로 보냄
			for (int j = 0; j < n - 1 - i; ++j)
			{
				if (arr[j] > arr[j + 1])
				{					
					swap(arr[j], arr[j + 1]);
					swapped = true;
				}
			}

			if (swapped == false)
			{
				break;
			}
		}
	}

	void BubbleSort_Main()
	{
		int n = 0;
		cin >> n;

		int v = 0;
		vector<int> arr;
		for (int i = 0; i < n; ++i)
		{
			cin >> v;
			arr.emplace_back(v);
		}

		BubbleSort(arr, n);

		for (int i = 0; i < n; ++i)
		{
			cout << arr[i] << " ";
		}
	}
}