#pragma once

/*
Bitmask
- bit 를 활용해 집합(subset)이나 상태(state)를 효율적으로 표현하고 다루는 기법
- 코딩 테스트에서 특히 부분 집합 열거, 상태 압축 DP 등에 자주 쓰임

1. Bit 와 정수의 관계
- 32bit int 는 내부적으로 32개의 bit(0, 1)로 구성
- 예) 10진수 5는 이진수로 ...00000101 이고, bit 0, 2번이 켜져 있는 상태

비트 위치		…	3	2	1	0
--------------------------------------
값(2의 거듭제곱)	…	8	4	2	1
5의 비트열		…	0	1	0	1

2. Bit 연산 기본

연산			기호		설명								예시
----------------------------------------------------------------------------
AND			&		둘 다 1일 때만 1					5 & 1 = 1 (101 & 001)
OR			&#124;	하나라도 1이면 1					`5
XOR			^		서로 다르면 1						5 ^ 1 = 4 (101 ^ 001)
NOT			~		비트 반전						~5 = …11111010
좌측 시프트	<<		비트들을 왼쪽으로 밀기 (×2ⁿ)		1<<3 = 8
우측 시프트	>>		비트들을 오른쪽으로 밀기 (÷2ⁿ)		8>>2 = 2

3. Bitmask로 부분집합 표현하기
- N개의 원소가 있을 때, 0번부터 N-1번까지의 Bit를 켜고 끄는 방식으로 "어떤 원소를 선택했는지"를 0 ~ (2^n - 1) 범위의 정수 하나로 표현 가능

예) N = 3 일 때
	- mask = 0b011 은 { 원소 0, 원소 1 }을 선택한 상태
	- mask = 5 (ob101) 은 { 원소 0, 원소 2 }를 선택한 상태
	- 가능한 mask는 0부터 7까지 (총 8개)


4. 부분집합 열거
void EnumerationSubsets() 예제
- 위의 예제와 같이 하면 O(2^n * N) 시간에 모든 부분집합을 열거할 수 있음
- N 최대 20까지는 무난히 사용가능

5. 상태 압축 DP 
- 예 : 외판원 문제 (TSP)
- N <= 16 정도일 때 종종 쓰이는 기법
- dp[mask][i] = "방문한 도시 집합이 mask이고, 마지막에 i도시에 있을 떄 최소 비용"

void TSP()

- 최종 답 : dp[(1 << N) - 1][i] + cost[i][start] 의 최소값
- 시간 복잡도는 O(2^n * N^2), N = 16 정도면 약 10^8연산 이내로 가능
*/

// 3번 예제
// Bit 체크 & 조작
void Subset();

// 4번 예제
// 부분집합 열거 예제
void EnumerationSubsets();

// 5번 예제
void TSP();